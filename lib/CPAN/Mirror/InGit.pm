package CPAN::Mirror::InGit;
use Git::Raw::Repository;
use Scalar::Util 'blessed';
use Parse::LocalDistribution;
use Carp;
use Moo;
use v5.36;

=head1 SYNOPSIS

  my $gitmirror= CPAN::Mirror::InGit->new(repo => $path_to_git_repo);
  my $snapshot= $gitmirror->snapshot($git_branch_name);
  # (all interesting methods are found on Snapshot objects)

=head1 DESCRIPTION

CPAN::Mirror::InGit is a concept that your entire CPAN mirror (or maybe more correctly a
DarkPAN) lives within a Git repository.  You designate a branch for each of your perl
environments (such as one branch per application) and that branch contains B<ONLY> the dist
tarballs used by that project, and an index of the packages within.

=head3 Features

=over

=item *

It's your own private CPAN (DarkPAN) with all the benefits that entails.  (such as private
dists or patching public dists)

=item *

The data is stored in Git, so it's version controlled and compressed.  This module reads
directly from the Git repo storage without needing a checkout.

=item *

The server serves each B<branch> as its own mirror URL, so it's actually like an unlimited
number of DarkPANs hosted on the same server.  Each branch indexes only the dist files you
have added to that branch, and only one version per dist.

=item *

There is a web interface that helps you pull new versions of dists from public CPAN, review
the changes and compare diffs of the module code, chain-pull new dependencies, and commit the
new dist versions into a branch.  The web interface also helps you apply patches to public
dists and maintains the history of those patches.

=item *

You can revert to a previous environment for your application with a simple "git revert".
(or use the web interface)

=item *

Removes the need for cpanfile.snapshot or carton, because now the DarkPAN mirror is versioning
your environment for each application.

=back

=head1 ATTRIBUTES

=head2 repo

An instance of L<Git::Raw::Repository> (which wraps libgit.so) for accessing the git structures.
You can pass this attribute to the constructor as a simple directory path which gets inflated
to a Repository object.

=head2 upstream_mirror

The URL of the upstream CPAN mirror, from which packages will be fetched.

=head2 package_cache_branch_name

The git branch name used for holding package files.  This prevents files from getting fetched
multiple times as they are pulled into other branches.

=head2 git_author_name

Name used for commits generated by this library.  Defaults to 'CPAN::Mirror::InGit'

=head2 git_author_email

Email used for commits generated by this library.  Defaults to 'CPAN::Mirror::InGit@localhost'

=head2 useragent

The L<Mojo::UserAgent> object used when downloading files from the real CPAN.

=cut

has repo                      => ( is => 'ro', required => 1, coerce => \&_open_repo );
has upstream_mirror           => ( is => 'ro', required => 1, default => 'https://www.cpan.org/' );
has package_cache_branch_name => ( is => 'ro', default => 'package-cache' );
has git_author_name           => ( is => 'rw', default => 'CPAN::Mirror::InGit' );
has git_author_email          => ( is => 'rw', default => 'CPAN::Mirror::InGit@localhost' );
has _snapshot_cache           => ( is => 'rw' );

has useragent                 => ( is => 'lazy' );
sub _build_useragent($self) {
   return Mojo::UserAgent->new;
}

sub _open_repo($thing) {
   return $thing if blessed($thing) && $thing->isa('Git::Raw::Repository');
   return Git::Raw::Repository->open("$thing");
}

=head1 METHODS

=head2 snapshot

  $snapshot= $gitmirror->snapshot($branch_or_tag_or_id);

Return a snapshot for the given branch name, git tag, or Git commit hash.  This may return a
cached object.

=cut

sub snapshot($self, $branch_or_tag_or_id) {
   my ($tree, $origin)= $self->lookup_tree($branch_or_tag_or_id);
   if (blessed($branch_or_tag_or_id) && $branch_or_tag_or_id->isa('Git::Raw::Branch') && !$origin) {
      Carp::confess();
   }
   if ($origin && ref $origin eq 'Git::Raw::Branch') {
      return $self->{_snapshot_cache}{$origin->name} //= 
         CPAN::Mirror::InGit::Snapshot->new(
            parent => $self,
            branch => $origin,
            tree => $tree,
         );
   } else {
      return CPAN::Mirror::InGit::Snapshot->new(
         parent => $self,
         tree => $tree,
      );
   }
}

=head2 package_cache

Return the Snapshot object for the package-cache git branch (or name specified in
L</package_cache_branch_name>).  This creates the git branch if it doesn't already exist.

=cut

sub package_cache($self) {
   my $branch= Git::Raw::Branch->lookup($self->repo, $self->package_cache_branch_name, 1);
   if (!$branch) {
      # Create an empty directory
      my $empty_dir= Git::Raw::Tree::Builder->new($self->repo)->write
         or croak;
      my $signature= $self->new_signature
         or croak;
      # Wrap it with an initial commit
      my $commit= Git::Raw::Commit->create($self->repo, "Initial empty tree", $signature, $signature,
         [], $empty_dir, 'refs/heads/'.$self->package_cache_branch_name)
         or croak;
      # Create the branch
      #$branch= Git::Raw::Branch->create($self->repo, $self->package_cache_branch_name, $commit)
      #   or croak;
   }
   return $self->snapshot($branch);
}

=head2 lookup_tree

Return the L<Git::Raw::Tree> object for the given branch name, git tag, or commit hash.
Returns undef if not found.  In list context, it returns both the tree and the origin object
(commit, branch, or tag) for that tree.  This does not use the Snapshot cache.

=cut

sub lookup_tree($self, $branch_or_tag_or_id) {
   my ($tree, $origin);
   defined $branch_or_tag_or_id or croak "missing argument";
   if (blessed($branch_or_tag_or_id) && (
         $branch_or_tag_or_id->isa('Git::Raw::Branch')
      || $branch_or_tag_or_id->isa('Git::Raw::Tag')
   )) {
      $origin= $branch_or_tag_or_id;
      $tree= $origin->peel('tree');
   }
   elsif ($origin= eval { Git::Raw::Branch->lookup($self->repo, $branch_or_tag_or_id, 1) }) {
      $tree= $origin->peel('tree');
   } elsif ($origin= eval { Git::Raw::Tag->lookup($self->repo, $branch_or_tag_or_id) }) {
      $tree= $origin->peel('tree');
   } elsif (my $obj= eval { $self->repo->lookup($branch_or_tag_or_id) }) {
      if ($obj->type == Git::Raw::Object::COMMIT()) {
         $origin= Git::Raw::Commit->lookup($self->repo, $obj->id);
         $tree= $origin->tree;
      } elsif ($obj->type == Git::Raw::Object::TREE()) {
         $tree= Git::Raw::Tree->lookup($self->repo, $obj->id);
      } elsif ($obj->type == Git::Raw::Object::TAG()) {
         $origin= Git::Raw::Tag->lookup($self->repo, $obj->id);
         $tree= $origin->target;
      }
   }
   return wantarray? ($tree, $origin) : $tree;
}

=head2 new_signature

Returns a L<Git::Raw::Signature> that will be used for commits authored by this module.
Signatures contain a timestamp, so the library generates new signatures frequently during
operation.

=cut

sub new_signature($self) {
   Git::Raw::Signature->now($self->git_author_name, $self->git_author_email);
}

=head2 get_dist_index

  my $index= $darkpan->get_dist_index($author_path_or_sha1_or_gitobj);
  # {
  #   'Package::Name' => $version,
  #   ...
  # }

Like the CPAN indexer, this takes a distribution tarball and returns the packages and versions
which it contains.  The index is built by L<Parse::LocalDistribution> and may be returned form
cache.

=cut

sub get_dist_index {
   ...
   # If git obj or sha1 provided
   #    look for cache at ->package_cache->get_blob("index_cache/$sha1")
   #    return cache if found
   #    extract to a tar.gz tmp file
   # extract tarball path to a tmpdir
   # run Parse::LocalDistribution on it.
   # cache the result into git if the source came from git
}

1;
