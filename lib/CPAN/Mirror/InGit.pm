package CPAN::Mirror::InGit;
use Git::Raw::Repository;
use Archive::Tar::Constant; # for constants to be avilable at compile time
use Scalar::Util 'blessed';
use Parse::LocalDistribution;
use CPAN::Mirror::InGit::MirrorTree;
use Carp;
use Moo;
use v5.36;

=head1 SYNOPSIS

  my $cpan_repo= CPAN::Mirror::InGit->new(repo => $path_to_git_repo);
  my $mirror_tree= $cpan_repo->branch_mirror($git_branch_name);
  # (all interesting methods are found on Mirror objects)

=head1 DESCRIPTION

C<CPAN::Mirror::InGit> is a concept that your entire CPAN mirror (or maybe more correctly a
DarkPAN) lives within a Git repository.  You designate a branch for each of your perl
environments (such as one branch per application) and that branch contains B<ONLY> the dist
tarballs used by that project, and an index of the packages within.

=head3 Features

=over

=item *

It's your own private CPAN (DarkPAN) with all the benefits that entails.  (such as private
dists or patching public dists)

=item *

The data is stored in Git, so it's version controlled and compressed.  This module reads
directly from the Git repo storage without needing a checkout.

=item *

The server serves each B<branch> as its own mirror URL, so it's actually like an unlimited
number of DarkPANs hosted on the same server.  Each branch indexes only the dist files you
have added to that branch, and only one version per dist.

=item *

There is a web interface that helps you pull new versions of dists from public CPAN, review
the changes and compare diffs of the module code, chain-pull new dependencies, and commit the
new dist versions into a branch.  The web interface also helps you apply patches to public
dists and maintains the history of those patches.

=item *

You can revert to a previous environment for your application with a simple "git revert".
(or use the web interface)

=item *

Removes the need for cpanfile.snapshot or carton, because now the DarkPAN mirror is versioning
your environment for each application.

=back

=head1 ATTRIBUTES

=head2 repo

An instance of L<Git::Raw::Repository> (which wraps libgit2.so) for accessing the git structures.
You can pass this attribute to the constructor as a simple directory path which gets inflated
to a Repository object.

=head2 upstream_mirror

The URL of the upstream CPAN mirror, from which packages will be fetched.

=head2 dist_cache_branch_name

The git branch name used for holding package files.  This prevents files from getting fetched
multiple times as they are pulled into other branches.

=head2 git_author_name

Name used for commits generated by this library.  Defaults to 'CPAN::Mirror::InGit'

=head2 git_author_email

Email used for commits generated by this library.  Defaults to 'CPAN::Mirror::InGit@localhost'

=head2 useragent

The L<Mojo::UserAgent> object used when downloading files from the real CPAN.

=cut

has repo                      => ( is => 'ro', required => 1, coerce => \&_open_repo );
has upstream_mirror           => ( is => 'ro', required => 1, default => 'https://www.cpan.org/' );
has dist_cache_branch_name    => ( is => 'ro', default => 'dist-cache' );
has git_author_name           => ( is => 'rw', default => 'CPAN::Mirror::InGit' );
has git_author_email          => ( is => 'rw', default => 'CPAN::Mirror::InGit@localhost' );

has workdir_branch_name       => ( is => 'lazy' );
sub _build_workdir_branch_name($self) {
   return undef if $self->repo->is_bare || $self->repo->is_head_detached;
   return $self->repo->head->shorthand;
}

has useragent                 => ( is => 'lazy' );
sub _build_useragent($self) {
   return Mojo::UserAgent->new;
}

sub _open_repo($thing) {
   return $thing if blessed($thing) && $thing->isa('Git::Raw::Repository');
   return Git::Raw::Repository->open("$thing");
}

=head1 METHODS

=head2 mirror

  $mirror= $cpan_repo->mirror($branch_or_tag_or_id, $create=0);

Return a L<MirrorTree object|CPAN::Mirror::InGit::MirrorTree> for the given
branch name, git tag, or commit hash.  This branch must look like a mirror
(having modules/02packages.details.txt) or it will return C<undef>, unless you
specify C<$create>, in which case the branch will be fleshed out with the
necessary files.  If C<$create> is specified, the C<$branch_or_tag_or_id> must
be a branch name or L<Git::Raw::Branch> object.

=cut

sub mirror($self, $branch_or_tag_or_id=undef, $create=0) {
   my ($tree, $origin, $mirror);
   if (defined $branch_or_tag_or_id) {
      ($tree, $origin)= $self->lookup_tree($branch_or_tag_or_id);
      return undef unless $tree or $create;
   }
   my $branch= $origin && ref($origin)->isa('Git::Raw::Branch')? $origin : undef;
   # undefined, or the same branch pointed to by HEAD mean that it should use the working tree
   my $use_workdir= !$self->repo->is_bare && (!defined $origin || ($branch && $branch->is_head));
   $mirror= CPAN::Mirror::InGit::MirrorTree->new(
      parent => $self,
      tree => $tree,
      (branch => $branch)x!!$branch,
      use_workdir => $use_workdir,
   );
   # To be recognized as a mirror, the tree must contain modules/02packages.details.txt
   unless ($mirror->module_manifest_blob) {
      return undef unless $create;
      $mirror->save_module_manifest;
   }
   return $mirror;
}

=head2 create_mirror

  $mirror= $cpan_repo->create_mirror($branch_name);



=head2 dist_cache

  $dists= $cpan_repo->dist_cache;

Return the L<DistCache|CPAN::Mirror::InGit::DistCache> representing the C<'dist-cache'>
git branch (or name specified in L</dist_cache_branch_name>).  This creates the git branch
if it doesn't already exist.

=cut

sub dist_cache($self) {
   my $branch= Git::Raw::Branch->lookup($self->repo, $self->dist_cache_branch_name, 1);
   if (!$branch) {
      # Create an empty directory
      my $empty_dir= Git::Raw::Tree::Builder->new($self->repo)->write
         or croak;
      my $signature= $self->new_signature
         or croak;
      # Wrap it with an initial commit
      my $commit= Git::Raw::Commit->create($self->repo, "Initial empty package cache",
         $signature, $signature, [], $empty_dir, 'refs/heads/'.$self->dist_cache_branch_name)
         or croak "Failed to create package cache initial commit";
      # Create the branch
      $branch= Git::Raw::Branch->create($self->repo, $self->dist_cache_branch_name, $commit)
         or croak 'Failed to create branch '.$self->dist_cache_branch_name;
   }
   return CPAN::Mirror::InGit::DistCache->new(parent => $self, branch => $branch);
}

sub has_dist_cache($self) {
   return !!Git::Raw::Branch->lookup($self->repo, $self->dist_cache_branch_name, 1);
}

=head2 lookup_tree

  $tree= $cpan_repo->lookup_tree($branch_or_tag_or_commit);
  ($tree, $origin)= $cpan_repo->lookup_tree($branch_or_tag_or_commit);

Return the L<Git::Raw::Tree> object for the given branch name, git tag, or commit hash.
Returns C<undef> if not found.  In list context, it returns both the tree and the origin object
(commit, branch, or tag) for that tree.

=cut

sub lookup_tree($self, $branch_or_tag_or_id) {
   my ($tree, $origin);
   defined $branch_or_tag_or_id or croak "missing argument";
   if (blessed($branch_or_tag_or_id) && (
         $branch_or_tag_or_id->isa('Git::Raw::Branch')
      || $branch_or_tag_or_id->isa('Git::Raw::Tag')
   )) {
      $origin= $branch_or_tag_or_id;
      $tree= $origin->peel('tree');
   }
   elsif ($origin= eval { Git::Raw::Branch->lookup($self->repo, $branch_or_tag_or_id, 1) }) {
      $tree= $origin->peel('tree');
   } elsif ($origin= eval { Git::Raw::Tag->lookup($self->repo, $branch_or_tag_or_id) }) {
      $tree= $origin->peel('tree');
   } elsif (my $obj= eval { $self->repo->lookup($branch_or_tag_or_id) }) {
      if ($obj->type == Git::Raw::Object::COMMIT()) {
         $origin= Git::Raw::Commit->lookup($self->repo, $obj->id);
         $tree= $origin->tree;
      } elsif ($obj->type == Git::Raw::Object::TREE()) {
         $tree= Git::Raw::Tree->lookup($self->repo, $obj->id);
      } elsif ($obj->type == Git::Raw::Object::TAG()) {
         $origin= Git::Raw::Tag->lookup($self->repo, $obj->id);
         $tree= $origin->target;
      }
   }
   return wantarray? ($tree, $origin) : $tree;
}

=head2 add_git_tree_to_tar

  $mirrorInGit->add_git_tree_to_tar($tar, $path, $tree);

This utility function adds L<Git trees|Git::Raw::Tree> to a L<tar archve|Archive::Tar>,
calling L</add_git_dirent_to_tar> for each entry.  C<$path> provides the name for the root
of the tree within the archive.  C<undef> or empty string means the tree I<will be> the root of
the archive.

=head2 add_git_dirent_to_tar

  $mirrorInGit->add_git_dirent_to_tar($tar, $path, $dirent);

This utility function adds L<Git directory entries|Git::Raw::Tree::Entry> to a
L<tar archve|Archive::Tar>.  It recurses subdirectories and handles symlinks.
The C<$path> is used for the destination name instead of C<< $dirent->name >>.

=cut

sub add_git_tree_to_tar($self, $tar, $path, $tree) {
   unless ($tree->can('entries')) {
      my $id= $tree;
      $tree = Git::Raw::Tree->lookup($self->repo, $id)
         or die "Can't find TREE $id referenced by '$path'";
   }
   $self->add_git_dirent_to_tar($tar, "$path/".$_->name, $_)
      for $tree->entries;
}

sub add_git_dirent_to_tar($self, $tar, $path, $dirent) {
   if ($dirent->type == Git::Raw::Object::BLOB()) {
      my $mode = $dirent->file_mode;
      my $blob = Git::Raw::Blob->lookup($self->repo, $dirent->id)
         or die "Can't find BLOB ".$dirent->id." referenced by '$path'";
      # Check if it's a symlink (mode 0120000 or 40960 decimal)
      if (($mode & 0170000) == 0120000) {
         # Symlink: content is the target path
         $tar->add_data($path, $blob->content, { 
            mode => $mode,
            type => Archive::Tar::Constant::SYMLINK,
            linkname => $blob->content
         });
      }
      else {
         # Regular file
         $tar->add_data($path, $blob->content, { mode => $mode });
      }
   }
   elsif ($dirent->type == Git::Raw::Object::TREE()) {
      $self->add_git_tree_to_tar($tar, $path, $dirent->id);
   }
   else {
      warn "Omitting $path from TAR, not a BLOB or TREE";
   }
}

=head2 new_signature

Returns a L<Git::Raw::Signature> that will be used for commits authored by this module.
Signatures contain a timestamp, so the library generates new signatures frequently during
operation.

=cut

sub new_signature($self) {
   Git::Raw::Signature->now($self->git_author_name, $self->git_author_email);
}

=head2 get_dist_index

  my $index= $darkpan->get_dist_index($author_path_or_sha1_or_gitobj);
  # {
  #   'Package::Name' => $version,
  #   ...
  # }

Like the CPAN indexer, this takes a distribution tarball and returns the packages and versions
which it contains.  The index is built by L<Parse::LocalDistribution> and may be returned form
cache.

=cut

sub get_dist_index {
   ...
   # If git obj or sha1 provided
   #    look for cache at ->dist_cache->get_blob("index_cache/$sha1")
   #    return cache if found
   #    extract to a tar.gz tmp file
   # extract tarball path to a tmpdir
   # run Parse::LocalDistribution on it.
   # cache the result into git if the source came from git
}

1;
