#! /usr/bin/env perl
use Mojolicious::Lite;
use FindBin;
use Git::Raw::Object;
use Archive::Tar;
use IO::Compress::Gzip qw( gzip $GzipError );
BEGIN { push @INC, "$FindBin::RealBin/../lib" if -f "$FindBin::RealBin/../dist.ini" }
use CPAN::Mirror::InGit;
use v5.36;

my $repo= $ENV{GIT_DIR};
if (!$repo) {
   for (0 .. $#ARGV) {
      if ($ARGV[$_] =~ /^--git-dir(?:=(.*))?/) {
         splice(@ARGV, $_, 1);
         $repo= $1 // splice(@ARGV, $_, 1);
         last;
      }
   }
}
defined $repo or die "Require --git-dir=X option or GIT_DIR=X environment variable\n";
-d $repo or die "No such directory: '$repo'\n";

my $mig= CPAN::Mirror::InGit->new(repo => $repo);

=head1 ROUTES

=head2 Cpan Mirror Paths

A functioning CPAN mirror requires a file /modules/02packages.details.txt.gz which lists the
full contents of the latest version of every module.  That file also lists the author paths
for each module, which are relative to /authors/id/

In this repo, /modules/02packages.details.txt is stored uncompressed, and gzipped as it is
served.  Each author dist is stored as a .tar.gz file and a metadata file with extension .json
and may also optionally be unpacked at a directory of the same name minus the .tar.gz extension.
A special author "local" is used for custom overrides of upstream packages.

Summary:

  /:branch/modules/02packages.details.txt                 # index of the mirror
  /:branch/authors/id/D/DP/DPARIS/Crypt-DES-2.07.tar.gz   # copy of upstream
  /:branch/authors/id/D/DP/DPARIS/Crypt-DES-2.07.json     # extracted metadata
  /:branch/authors/id/local/Crypt-DES-2.07_01/...         # untarred customized dist
  /:branch/authors/id/local/Crypt-DES-2.07_01.json        # untarred customized dist's metadata

=cut

get '/:root/*filepath' => sub ($c) {
   my $id= $c->param('root');
   my $path= $c->param('filepath') // '';
   # cpanm adds extra '/' when the path name doesn't match the expected A/AU/AUTHOR format
   $path =~ s,//+,/,g;
   $path =~ s,^/,,;
   my ($basename)= ($path =~ m,([^/]+)\z,);
   my ($tree, $dirent);
   # Every mirror must have a modules/02packages.details.txt, or else maybe it isn't a mirror.
   ($tree= $mig->lookup_tree($id))
   && ($dirent= $tree->entry_bypath('modules/02packages.details.txt'))
   && ($dirent->type == Git::Raw::Object::BLOB())
      or return $c->render(status => 404, text => 'Specified branch/commit/tag/SHA1 does not exist or is not a CPAN mirror');
   $c->log->debug("Branch $id is TREE ".$tree->id);
   # Does the exact file exist?
   $dirent= $tree->entry_bypath($path);
   $c->log->debug("Path $path is ".($dirent? $dirent->id : '<undef>'));
   if ($dirent) {
      if ($dirent->type == Git::Raw::Object::BLOB()) {
         my $blob= Git::Raw::Blob->lookup($mig->repo, $dirent->id)
            or return $c->render(status => 500, text => 'Referenced Git BLOB does not exist');
         $c->res->headers->content_disposition("attachment; filename=$basename;");
         $c->render(data => $blob->content);
      } else {
         $c->render(status => 403, text => 'not a file');
      }
   }
   elsif ($path =~ /(.*?)\.gz\z/ && ($dirent= $tree->entry_bypath($1)) && $dirent->type == Git::Raw::Object::BLOB()) {
      $c->log->debug("Path $1 is ".$dirent->id.', will gzip it');
      my $blob= Git::Raw::Blob->lookup($mig->repo, $dirent->id)
         or return $c->render(status => 500, text => 'Referenced Git BLOB does not exist');
      $c->render_gzipped($blob->content, $basename);
   }
   elsif ($path =~ /(.*?)\.tar\.gz\z/ && ($dirent= $tree->entry_bypath($1)) && $dirent->type == Git::Raw::Object::TREE()) {
      $c->log->debug("Path $1 is ".$dirent->id.', will tar+gzip it');
      my $subtree = Git::Raw::Tree->lookup($mig->repo, $dirent->id)
         or return $c->render(status => 500, text => 'Referenced Git TREE does not exist');
      my $tar= Archive::Tar->new;
      $mig->add_git_tree_to_tar($tar, substr($basename, 0, -7), $subtree);
      $c->render_gzipped($tar->write, $basename);
   }
   else {
      return $c->render(status => 404, text => 'No such path in branch');
   }
};

app->helper(render_gzipped => sub ($c, $data, $filename='') {
   my $gzipped;
   gzip \$data => \$gzipped
     or return $c->reply->exception("gzip failed: $GzipError");
   $c->res->headers->content_type('application/gzip');
   $c->res->headers->content_disposition(qq{"attachment; filename="$filename;"})
      if length $filename;
   return $c->render(data => $gzipped);
});

app->start;
